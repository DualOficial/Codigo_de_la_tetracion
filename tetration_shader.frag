#version 330 core
#ADD ORTOGONAL SHADER

//Base e^1/e

vec2 natural_tet_integer( vec2 z , int n ){
	
	if( n >= 0 ){
		
		while( n > 0 ){
			
			z = exp( z / e );
			n--;

		}

		return z;
	}

	n = -n;

	while( n > 0 ){
		
		z = log( z ) * e;
		n--;

	}

	return z;
}

vec2 natural_tet( vec2 x , vec2 y ){
	
	vec2 a = natural_tet_integer( x , -value );

	return natural_tet_integer( asc( a + vk( 1 - e ) , y / ( e * 2.0 ) ) + vk( e - 1 ) , value );
}

vec2 natural_gen( vec2 x , vec2 y ){
	
	return d( vk( e * 2.0 ) , natural_tet_integer( x , -value ) - vk( e ) ) - d( vk( e * 2.0 ) ,  natural_tet_integer( y , -value ) - vk( e ) );

}

//Base e
//Esta tetración casi no tiene precisión

vec2 tet( vec2 z ){
	
	vec2 final_exp = vk( 2.0 );
	vec2 height = z;

	vec2 v = vec2( 0.3181315052047641353121 , 1.33723570143068940890 );
	vec2 a = v - vk( 1.0 );
	vec2 b = e_tetration_integer( final_exp , -value ) - a;
	
	vec2 y = pow( v , height );
	vec2 x = ( d( y - vk( 1.0 ) , v - vk( 1.0 ) ) - y + vk( 1.0 ) ) / 2.0;

	return e_tetration_integer( pow( b , p( y , pow( b , x ) ) ) + a , value );
}

//Alpha Derivate Algorithm

float factorial( float k ){
	
	float r = 1.0;

	for( float i = 1; i <= k; i++ ){
		
		r *= i;

	}
	
	return r;
}

vec2 v0 = vec2(0.3181315052047641353126542515876645172035176138714048,1.337235701430689408901162143193710612539502138460512) / factorial( 0 );
vec2 v1 = vec2(0.9199697049219804666911757744245158931410482535237969,0.7267824659204923854082068222411697217046000669303214) / factorial( 1 );
vec2 v2 = vec2(0.5444367456232741730929185975307049552351030330982572,0.1724482342350999088234068362168849809363841189336084) / factorial( 2 );
vec2 v3 = vec2(0.106843471264890473486350283313987538045207061648842,0.01561652155827337058224752889043212152935044566232995) / factorial( 3 );
vec2 v4 = vec2(0.07854540011851279382553022631119705847055083506699241,-0.0153719367584218146670885277041829163939047199664483) / factorial( 4 );
vec2 v5 = vec2(-0.2200800373124322989203643809392675290604041453002812,0.3462963293875575843422664833538908442712751927691642) / factorial( 5 );
vec2 v6 = vec2(-2.260877518676347551574262187863194448379234307425556,-2.14984109358418163257080589123723099208616200444634) / factorial( 6 );
vec2 v7 = vec2(12.93619654604917863910128794422093580411618005796299,-15.73739998426389404937352562922178004592996414521458) / factorial( 7 );
vec2 v8 = vec2(102.0806788959624167985822954838644622368405134093014,66.60699178177363017703030419078339910504476277730122) / factorial( 8 );
vec2 v9 = vec2(-332.3254830079439108652838753257195919134465963143308,622.3460361371498993078956970797815864547496721264637) / factorial( 9 );
vec2 v10 = vec2(-3596.497762300994532171737195139250573935943218156936,-1735.732011083951115573103066331340335964272219473825) / factorial( 10 );
vec2 v11 = vec2(10267.51097622702274205975997761836242666483027085977,-18976.00067295173643159991057539999061253810711280539) / factorial( 11 );
vec2 v12 = vec2(76508.95489387618227964010375682886326650562991069394,74965.20259892646511120789817795374620970115965341005) / factorial( 12 );
vec2 v13 = vec2(-696929.6074541035097968878310956726506239687580339685,-37941.54586540734530719872720546109848820662525732873) / factorial( 13 );
vec2 v14 = vec2(6550459.660496413392559977862522729043217666917127941,-7715864.137420130646770329174223065415614081718105144) / factorial( 14 );
vec2 v15 = vec2(92272836.40288271068572711084220778757830040200531182,117377123.745022922220926962796933007696565642961146) / factorial( 15 );
vec2 v16 = vec2(-1651062067.990868591409789519481465292972588422694699,1113389060.693196703867320285433657818707674717531323) / factorial( 16 );
vec2 v17 = vec2(-12989368634.93378871840204307544923305910291376589462,-21284867369.95333360405699661223329611404051063516819) / factorial( 17 );
vec2 v18 = vec2(264179424056.6065703828256447308607516270662162860089,-140322602681.7565058434977778041329835249250261026463) / factorial( 18 );
vec2 v19 = vec2(1281835054286.353441946077638089876313629280175191131,3228149057207.492508462704607066943930231009926554322) / factorial( 19 );
vec2 v20 = vec2(-39123975489992.60325917664247778957362354396422970695,6617169790981.837991981713821262692896484036685581484) / factorial( 20 );
vec2 v21 = vec2(94997691777216.90024195223236985247533615976989829353,-469383256220414.5392912394641008308820257036802209032) / factorial( 21 );
vec2 v22 = vec2(5663118041530312.080481394568697902353795145056943259,4497791639054646.489959870904936485123227991485725259) / factorial( 22 );
vec2 v23 = vec2(-114563148775708181.0683043330974061203015031976881757,61695369769802191.52301098722727616892960152140093478) / factorial( 23 );
vec2 v24 = vec2(-487075561715334732.7872809687163018438172638618192433,-2414894575857040942.047002429527327817639099584259605) / factorial( 24 );
vec2 v25 = vec2(44762991880007564453.05379278466787776630600595745202,-2232774523395700183.188635458807696255514606507753085) / factorial( 25 );
vec2 v26 = vec2(16014318633038950247.44442878825347844656360128937067,725222939587673131870.661223544154437311704309778185) / factorial( 26 );

vec2 exphalf_positive( vec2 z ){
	
	int count = 0;

	while( module( z - v0 ) > 1.0 ){
		
		if( count > 30 ) discard;
		
		z = log( z );
		count++;

	}
	
	z -= v0;

	vec2 result = v0 + p( z , v1 ) + p( pow( z , 2 ) , v2 ) + p( pow( z , 3 ) , v3 ) + p( pow( z , 4 ) , v4 )
		+ p( pow( z , 5 ) , v5 ) + p( pow( z , 6 ) , v6 ) + p( pow( z , 7 ) , v7 ) + p( pow( z , 8 ) , v8 )
		+ p( pow( z , 9 ) , v9 ) + p( pow( z , 10 ) , v10 ) + p( pow( z , 11 ) , v11 ) + p( pow( z , 12 ) , v12 )
		+ p( pow( z , 13 ) , v13 ) + p( pow( z , 14 ) , v14 ) + p( pow( z , 15 ) , v15 )
		+ p( pow( z , 16 ) , v16 ) + p( pow( z , 17 ) , v17 ) + p( pow( z , 18 ) , v18 )
		+ p( pow( z , 19 ) , v19 ) + p( pow( z , 20 ) , v20 ) + p( pow( z , 21 ) , v21 )
		+ p( pow( z , 22 ) , v22 ) + p( pow( z , 23 ) , v23 ) + p( pow( z , 24 ) , v24 )
		+ p( pow( z , 25 ) , v25 ) + p( pow( z , 26 ) , v26 );

	return e_tetration_integer( result , count );
}

vec2 exphalf( vec2 z ){
	
	if( z.y < 0 ) return conj( exphalf_positive( conj( z ) ) );

	return exphalf_positive( z );
}

vec2 f( vec2 z ){
	
	return natural_tet( vk( 5.0 ) , z );

}

void main(){
	
	ortoper number = adjust( getCoords() );
	
	graph( f( to_orto( number ).z ) );
	
}
